---
fig_height: 2
fig_width: 3
output:
  pdf_document: default
  html_notebook: default
  html_document: default
---
### Household herding decisions predict winter pasture conditions in Mongolia using an integrated social-ecological analysis approach
##### María E. Fernández-Giménez, Ginger Allington, Jay Angerer, Robin Reid, Chantsallkham Jamsranjav, Tungalag Ulambayar
<br>
#### Table of Contents

[I. Notes][]

[II. Introduction][]

[III. Methods][]

[Matching method][]

[Outcome Variable][]

[Matching][]

[IV. Results][] 
```{r preliminaries, message=FALSE, echo = FALSE, warning=FALSE}
library(MatchIt)
library(optmatch)
library(foreign)
library(dplyr)
library(tidyr)
library(ggplot2)
library(magrittr)
library(gridExtra)
library(Zelig)
library(knitr)
library(xtable)
library(ggjoy)
library(cobalt)
library(dummy)
```

#### I. Notes
TO DOs and reminders:  
* fix RMD code to not print all the R code chunks along w the results...?
* insert ref to efa_cfa.Rmd exported pdf
* Qs re: latent means rescale then weighted---ok to interpret directly?
* add a table of variable name shortcuts for maria & robin & chantsaa to reference

### Abstract

### II. Introduction
* Global importance and threats to temperate grasslands and Mongolia as a key example
* Scaling challenges of linking social and ecological data to understand impacts and feedbacks in coupled human-natural systems, especially grasslands
*	Evidence from fine-scale grazing management experiments does not scale to ranch-level management units and does not account for human adaptive decision-making (Briske et al. 2008, subsequent papers and debate)
*	A few ranch-scale case studies are beginning to couple household-level decisions and management with ranch-scale ecological outcomes (Wilmer et al. in press, Teague et al, etc.). However, most of these studies are limited in the number of cases (<20 ranchers) and confined to a single ecological zone (e.g. E Colorado, S Texas). 
*	Evidence from extensive scale remote sensing studies that correlate greenness and livestock populations also overlook household and collective decision making at local scales and fail to overcome confounding of correlation and causation, leading to spurious conclusions. Also, they look at only one or two variables (greenness and land cover types)
*	This study draws on a unique multi-scalar integrated social-ecological data set that explicitly couples individual household decisions/behaviors and community-level institutions with pasture-level field-based ecological data and multi-scalar remote sensing and climate data to examine the impacts of household behavior and community-level institutions on ecological conditions, and vice versa, at the pasture scale (~250-500 ha), accounting for landscape context in the surrounding district (~10,000- xxx ha).
*	It applies a novel two (three?) step process that 1) uses a single robust, integrated and holistic index of ecological health as a response variable, and 2) compares ecological outcomes in sets of matched households for each management decision or institution, to determine the effects of each practice or institutional variable while accounting for potentially confounding influences.
*	As such, our study makes important methodological and empirical contributions to the study and understanding of coupled social-ecological systems in temperate grasslands grazed by domestic livestock. 
*	Methodologically it…
*	Empirically, it shows that herder decisions do matter and that key practices and institutional innovations have a measurable and beneficial impact on grassland ecological conditions in Mongolian winter pastures. [focus on the practices and institutions that matter the most…}
*	These results have important policy and management implications….

### III. Methods

##### General Notes on matching and propensity scores...

The goal of matching is to get trt and ctrl groups with similar distributions of covariates. Then when comparing trt effect on outcome , we can be more conifdent that we are actually detecting the impact of that trt (here it is CBRM or an individual practice) versus the confounding impact of the covariates. One advantage of matching methods is that we can identify areas where the covariate distributions do not sufficiently overlap, and exclude those samples from the subsequent analysis, as they would create additional bias (this is partic imp in subsequent linear modeling, etc.). Basically we are trying to reduce bias in our estimation of the effect of different "treatments" (practices, or institution)


The Standardized Diff in means should generally be < 0.25  (Some say 0.1)
Ratio of variances of the propensity scores should be around 1. 
Note: in matchIt the default label for propensity scores is "distance"
so that is often used below. 

Re: choosing variables for matching: "Include in the matching procedure any covariates that may be related to treatment assignment and the outcome"-(Stuart and Rubin 2007)
generally should not match on variables that are affected by the treatment assignment
Post-matching:
Use analyses appropriate for non-independent matched samples if more than one nonparticipant is matched to each participant
Note: When you have multiple matches for a single treated observation, it is essential to use Weighted Least Squares rather than OLS.
As the procedure only controls for observed variables, any hidden bias due to latent variables may remain after matching.
We are matching for a few different "treatments", each of which will be matched based on relevat covariates.
Starting first with CBRM status (Yes/No). We want to compare the outcomes re: ecological condition with this method compared to that of earlier studies that did not control for these confounding factors.  Then we will compare the ecological outcomes under individual practices (esp p4-p10).

One question: Should we just use exact matching for CBRM, since the original study was established to have a relatively balanced number of CBRM and non-CBRM households? 
Then potentially continue with full matching for the Practices 'treatments'?  
How best to include Trespassing? As a Trt? or a Covariate?

### Matching method
We are using 'optimal full matching', which will allow us to maintain the largest number of samples while also reducing bias

### Assessing balance
We assess overall balance through several measures.
1. Standardized Mean Difference (< 0.1-0.25 depending on context) between Treatment and Control, for the Matched and Unmatched datasets. 
2. Variance ratios (aim is close to 1) - between Treatment and Control, for the Matched and Unmatched datasets. 
3. Komologorov-Smirnoff tests of distribution. - between Treatment and Control, for the Matched and Unmatched datasets. We will also use this test to assess the ECDF of the outcome variable under the Treatment compared to the Control (post-matching)

We  also assess the overlap in teh distribution of the
**Propensity score** :the probability of *receiving* the treatment, given the observed covriates. We want to ensure that the p-scores are as similar as we can, before we start to estimate the effect of a given treatment.  They summarize all of the covariates in to a single scalar-- at each value of p-score, the distribution of the covariates is the same in teh trt and cntrl groups.

### Variable selection
From Stuart (2010) "include all vars known to be related to treatment assignment, and the outcome"
and/or: include set of covariates known to be realted to the outcome var, then check the balance on all/additional covariates. Then add in any addtnl covariates that seem really unmatched.

**DO NOT** include covariate that might be affected by the treatment!

### Data....
This includes MOR2 HH survey data, data from Jay Angerer on environmental parameters and forage availability and stockign density at the soum level.  And also the outcome variance, which I am generally referring to here as Ecological Integrity Index (please help me come up with a better name if you don't feel like that's a good choice). This Ecol Int Index value is the outcome of the Comfirmatory Factor Analysis (INSERT NAME OF the pdf once I've exported it from the Rmd). See that document for a description of the process of  generating the latent mean value for Ecological Integrity. The raw latent mean is scaled from -2 thru 2. I rescaled these values to be from 0-1. Then later they are weighted, resulting in a final range of values = [###].
--summary stats on that
--should these be set to quantiles?

### Outcome Variable
Generating the Ecological Integrity Index
(for now, see separate document on this)


```{r load, echo=FALSE, message=FALSE, warning=FALSE}
# STEP 1: subsetting the mor2 data:
# for use in matching....

# this is the data on just the 130 HH That have paired ecological data,along with their associated Organizational info
mor2<- read.spss("./data/ALL_EcolHHOrgMerged_byUvuljaa_03_15_17_Simplified.sav" , 
                 to.data.frame=TRUE,
                 use.value.labels=FALSE) #
# tidy format
#tbl_df(mor2)

# load jay's data on env params
soum_stats<- readRDS("./soum_stats.rds")

# load the latent means from the CFA
#   these are the extracted latent means from the cfa of ecological variables
#   this file was generated in the efa_cfa.Rmd doc.
#   THIS IS THE SINGLE FACTOR PREDICTIONS:
lvs<- readRDS("rpe_lv.R")
lvs$RefNum <- as.factor(lvs$RefNum)
#
#   THIS IS THE TWO FACTOR PREDICTIONS: 
eco.vars.pred <- readRDS("./data/eco.2latent.RDS")
eco.vars.pred$RefNum <- as.factor(eco.vars.pred$RefNum)

hhmatch <- mor2 %>%
  dplyr ::select(CBRM,
         AimagName,
         SoumCode,
         SoumName,
         ez = EcologicalZone_4Code,
         RefNum = SocialSurveyReferenceNumber,
         Trsp = AnotherAilLSOnPast
         ) 
hhmatch%<>% mutate_at(c(1,4,6), funs(factor(.)))            # ordered(.)))
hhmatch$SoumName <- trimws(as.character(hhmatch$SoumName))
hhmatch$AimagName <- trimws(as.character(hhmatch$AimagName))


#   Single factor Latent var
hhmatch %<>% left_join(lvs[,c(2, # RefNum
                              6, # r1
                              11:17, # p4-p10
                              22:24, # p1-p3
                              44,  # slope of ndvi
                              55   # eco int latent mean
                              )], by= "RefNum")


hhmatch %<>% left_join(soum_stats, by = c("AimagName", "SoumName"))


for(level in unique(hhmatch$ez)){
  hhmatch[paste("dummy", level, sep = "_")] <- ifelse(hhmatch$ez == level, 1, 0)
}
hhmatch %<>% rename(ez1_DS = dummy_1,
                ez2_St = dummy_2,
                ez3_ES = dummy_3,
                ez4_FMS = dummy_4)
# the "SoumID.x" that comes thru here is the Soum ID from Jay's jay, which do not match teh MOR2 codes, so i'm keeping them in for reference, just in case.

# NOW BRINGING IN THE TWO ECO FACTORS DATA:
#   this is the orig predicted values, NOT rescaled:

#tbl_df(eco.vars.pred)
matchy <- left_join(hhmatch,eco.vars.pred, by= "RefNum")

raw.data<- matchy %>% 
    na.omit() %>%
    mutate(eco.int = scales::rescale(eco.lv, to=c(0, 1))) %>%    
    mutate(eco1.rs = scales::rescale(eco1, to=c(0, 1))) %>%
    mutate(eco2.rs = scales::rescale(eco2, to=c(0, 1)))
```

### Table of the variables used in the analysis:
Eventually this will also list the units, a description and indicate which covariates were used in each matching exercise.  
**NOTE**: as of now Jay's data are summarized in two ways:  
1. long-term mean over all years in dataset  
2. means up to 2011  
A more appropriate measure is probably:  
3. Slope of trend through 2011, for the practices vars.  
But for the CBRM 'treatment', we want to be able to consider the context *at the time the CBRM was formed* or, in the years leading up to it. Which means we shoudl be using either:  
4. mean from start up to the year that the CBRM was formed  
5. slope of the trend up to the year it was formed.  
However, these were all happening on different years, and the dzud impacts the calc of lt-trend if we end it around that time. So, how shoudl we handle this?

**Table 1.** A full list of variables used in this analysis. (See Table 1 in the word & excell docs too). This will eventually also contain descriptios of the variables and the units and source. (hidden for now-- )

```{r, echo = FALSE, results= 'hide'}
# list of the params in the df
#str(hhmatch)
hname<- names(hhmatch)
kable(hname, format= "markdown", col.names = c("Variables"))

```



### Matching 

#### CBRM as Treatment
I'm including these bits of code so that you can see which variables have been included in each matching procedure. But eventually this will be condensed in to one Table. Potentially combined w Table 1. 
```{r, message=FALSE, warning=FALSE}

m.out1 <- matchit(CBRM ~ 
                    ez1_DS +
                    ez2_St +
                    ez3_ES +
                    ez4_FMS +
                    #AimagName +
                    #SoumName+
                    # slope +  # slope of ndvi at HHS
                     p4 +  # FAll Otor
                     p5 +   # Winter Otor
                     p6 +   # Res Pastures vars.
                     p7 +  
                     p8 +
                     ppt99 +  # mean precip up to 2011
                     sfu99,  # mean sfu up to 2011
                  data = raw.data, 
                  method = "full", distance = "logit",
                  discard = "both"
                  )
m.full.summary<- summary(m.out1, 
                         standardize = TRUE,  
                         addlvariables = raw.data[,c("p4")]) 
m.full.summary                                     
```
#### Retrieve summary of matched data and generate dataset
If matching is done well, the treatment and control groups will have (near) identical means of each covariate at each value of the propensity score.
Reminder: we are assessing good match on St Diff in Means of matched groups <0.2 and var ratio around 1.  But since we know that some of these can vary based on more than just means we should also consider a test of their distributions (like Komologrov-Smirnoff)

(I'm gong to insert this format of these data in here just this time. The rest of the examples will be with a diff output. I'm includin this as well as there is slightly diff info in it, just so everyone can see it.)
**CBRM : Summary of Final Sample Size**
```{r, results= 'asis', echo = FALSE}
knitr::kable(m.full.summary$nn, caption = "Summary of Final Sample Size")

# try to make a df out of that summary by calling indiv lists and then kable to table
```

**Summary Stats of CBRM & Non-CBRM un-matched**
```{r, results= 'asis', echo = FALSE}
#m.full.summary
knitr::kable(m.full.summary$sum.all, caption = "Summary Stats of CBRM & Non-CBRM un-matched", digits = 3)
```
**Summary Stats of CBRM & Non-CBRM Matched**
```{r, results= 'asis', echo = FALSE}
knitr::kable(m.full.summary$sum.matched, caption = "Summary Stats of CBRM & Non-CBRM Matched", digits = 3)
```

Export the data file.
```{r,  echo = FALSE}
full.data.m <- match.data(m.out1) # pulls matched data out of matchit object. 
## obtain matched data for the treatment group
#   keeping this here for reference in case need to export these later, but in general not using these separately
m.data.trt <- match.data(m.out1, group = "treat")
m.data.ctrl <- match.data(m.out1, group = "control")
```

### Plotting to compare the matched v. unmatched data

In assessing covariate balance we are looking for mean differences < 0.25, variance rations ~1  
And similar distributions between Trt and Ctrl, particularly for the Propensity Scores.

```{r, echo = FALSE}
# this is done with balance.plot but see also Johan's code for his versions of plottin these
# change variable names:
v <- data.frame(old = c("distance", "ez1_DS", "ez2_St", "ez3_ES", 
                        "ez4_FMS", "p4_0", "p5_0", "p6_0", 
                        "p7_0", "slope"),
                new = c("Propensity score", "Desert Steppe", "Steppe", 
                        "Eastern Steppe", "Forest/Mtn Steppe", "Fall Otor", "Winter Otor", 
                        "Reserve Winter Pastures", "Reserve Spring Pastures", "NDVI Trend"))
a<- love.plot(bal.tab(m.out1), 
          stat = "mean.diffs",  # c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2, 
          no.missing = TRUE,
          var.order = NULL,
         # colors = c("#998ec3","#f1a340"),
          var.names = v)
a
# try to figure out how to plot this so it looks nicer....
d<-bal.tab(m.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = .25, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE,
        var.names = v
        )
kable(d$Balance)
b<- bal.plot(m.out1, "distance", which = "unadjusted")+theme_bw()
c<- bal.plot(m.out1, "distance", which = "adjusted")+theme_bw() 
# this returns a ggplot object
#b+ theme_bw() # so just need to adjust the aesthetics.
c
#e<- grid.arrange(a,b,c, ncol=1, widths = 2)
ggsave(a, filename = "./plots/cbrm_balance.png") #, width=2, height = 7)
ggsave(b, filename = "./plots/cbrm_PSpre.png", width=5, height = 4)
ggsave(c, filename = "./plots/cbrm_PSpost.png", width=5, height = 4)
```

**hidden extra plotting info that i'm saving.....**
```{r, eval = FALSE, echo = FALSE}


# ********* DON'T RUN THIS!!!!!!!!!!!!! *******************



# generate pre and post matching Std. Mean. Diff. datasets
# this is SUMMARY data
full.sum.all <- m.full.summary$sum.all
full.sum.mat <- m.full.summary$sum.matched
full.sum.all <- rename(full.sum.all, StMeanDiff = "Std. Mean Diff.")
full.sum.mat <- rename(full.sum.mat, StMeanDiff = "Std. Mean Diff.")


# write matching results files
write.csv(full.sum.all, "./data/matching/full_prematching_hh.csv")
write.csv(full.sum.mat, "./data/matching/full_postmatching_hh.csv")

# generate column for covariates
covariates <- row.names(m.full.summary$sum.all)

# generate dataset for plotting
#### ASK JOHAN ABOUT THIS ONE NOT SURE 
StMeanDif <- data.frame(cbind(covariates, full.sum.all$StMeanDiff, full.sum.mat$StMeanDiff))
StMeanDif <- data.frame(cbind(covariates, full.sum.all$StMeanDiff, full.sum.mat$StMeanDiff))
StMeanDif$V2 <- as.numeric(paste(StMeanDif$V2))
StMeanDif$V3 <- as.numeric(paste(StMeanDif$V3))

# plot Standardized mean differences
stmdif.full <- ggplot(StMeanDif, aes(y = covariates )) +
  geom_point(aes(x = V3), colour = "sienna4", size = 8, alpha = 1) + geom_point(aes(x = V3), colour = "orange", size = 6, alpha = 1) + # with replacement
  geom_point(aes(x = V2), colour = "black", size = 7, alpha = 1, shape = 1) +
  scale_x_continuous(limits=c(-1, 1), breaks = c(-1, -0.5, -0.25, 0, 0.25, 0.5, 1, 1.5, 2, 2.5)) +
  geom_vline(xintercept = 0, lty="dotted") +
  geom_vline(xintercept = -0.25, lty="dotted") +
  geom_vline(xintercept = 0.25, lty="dotted") +
  theme_classic() +
  xlab("Std. mean difference") +
  ylab("Matching covariates") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"))
stmdif.full

### generate propensity scores for full (unmatched) dataset

raw.data <- match.data
pscores <- glm(CBRM ~
              ez + 
              Trsp +
              pl +
              p2s +
              p3s, 
            data = raw.data, family = binomial)


raw.data$ps <- predict(pscores, type = "response")

### Plot Propensity Scores before matching

full.pscore.pre <- ggplot(data=match.data) + 
  geom_density(data = raw.data[which(raw.data$CBRM == "0"), ], fill = "yellow3", color = "yellow4", alpha = 0.2, aes(x = ps)) +        
  geom_density(data = raw.data[which(raw.data$CBRM == "1"), ], fill = "navyblue", color = "mediumpurple4", alpha = 0.2, aes(x = ps)) + 
  xlim(-0.2, 1.2) +
#  ylim(0, 4) +       # set this to match the actual range of the data!!!!!
  theme_classic() +
  xlab("Propensity score") +
  ylab("Density") +
  ggtitle("Before Matching") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        plot.title = element_text(size=18, face = "bold", hjust = 0.5),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")
  )
full.pscore.pre

### Plot Propensity Scores after matching

full.pscore.post <- ggplot(data=full.data.m) + 
  geom_density(data = full.data.m[which(full.data.m$CBRM == "0"), ], fill = "yellow3", color = "yellow4", alpha = 0.2, aes(x = distance, weight = weights/sum(weights))) +
  geom_density(data = full.data.m[which(full.data.m$CBRM == "1"), ], fill = "navyblue", color = "mediumpurple4", alpha = 0.2, aes(x = distance)) +  # here distance = propensity score...
  xlim(-0.2, 1.2) +
#  ylim(0, 4) +
  theme_classic() +
  xlab("Propensity score") +
  ylab("Density") +
  ggtitle("After Matching") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        plot.title = element_text(size=18, face = "bold", hjust = 0.5),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")
  )
full.pscore.post


### plot matching figures

stmdif.full + scale_x_continuous(labels=scaleFUN)            # This should be 9" x 7" when exporting .pdf
grid.arrange(full.pscore.pre, full.pscore.post, ncol=1)      #  This should be 7" x 7" when exporting .pdf
```

### TRSP as Treatment

9/14: Take a look at what is happening w p1, and ez 1 and ez 2.
Also the variance ratios for long-term mean sfu var

```{r data, message=FALSE}

tr.full.summary<- summary(tr.out1 <- matchit(Trsp ~
                                          ltmeanppt +
                                          ltsdppt +
                                          ltmeansfu +  # NEED TO ADD HH LSK HERD SIZE TOO SOMEHOW - PROXY?
                                          avail.forage +
                                          CBRM + 
                                          ez1_DS +
                                          ez2_St +
                                          ez3_ES +
                                          ez4_FMS +
                                          pl +
                                          p2s +
                                          p3s ,
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE 
                                        )
# get summary and generate dataset
full.data.tr <- match.data(tr.out1) # pulls matched data out of matchit object. 

```
## Plot matching results:
### balance.plot
```{r, echo = FALSE}
love.plot(bal.tab(tr.out1), 
          stat = "mean.diffs",  # c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2, 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(tr.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = .1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(tr.out1, "distance", which = "both")
# this returns a ggplot object
b+ theme_bw() # so just need to adjust the aesthetics.

```

## PRACTICES as Treatments...
### p4: fall Otor

To discuss w Maria: Which other vars to include for matching?

See issue w poor matching w ez3--possibly bc so few?
Actually, none of the ez are improved w matching... remove all? 
Generally the mean diff is still pretty low for all and the overall match is good
So it might be more important to include?  This is an example of one where I want to 
talk some more w Kelly about what this really means/how it will influence our interpretation of results.

```{r P4, }

p4.full.summary<- summary(p4.out1 <- matchit(p4 ~
                                          CBRM + 
                                          ez1_DS +
                                          ez2_St +
                                          ez3_ES +
                                          ez4_FMS + 
                                          p6 +
                                          p7 +
                                          p8 +
                                          ltmeanppt +
                                          ltsdppt +
                                          ltmeansfu +  # NEED TO ADD HH LSK HERD SIZE TOO SOMEHOW - PROXY?
                                          avail.forage,
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
#p4.full.summary
full.data.p4 <- match.data(p4.out1) # pulls matched data out of matchit object. 


```

balance.plot
```{r, echo = FALSE}
love.plot(bal.tab(p4.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p4.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )

# 
b<- bal.plot(p4.out1, "distance", which = "both")
# this returns a ggplot object
b+ theme_bw() # so just need to adjust the aesthetics.
# ggsave(a, filename = "./plots/p4_balance.png") #, width=2, height = 7)
# ggsave(b, filename = "./plots/p4_PSpre.png", width=5, height = 4)
# ggsave(c, filename = "./plots/p4_PSpost.png", width=5, height = 4)
```

## p5: Winter Otor:

```{r P5,}

p5.full.summary<- summary(p5.out1 <- matchit(p5 ~
                                          CBRM + 
                                          ez + 
                                          p6 +
                                          p7 +
                                          p8 +
                                          ppt11 +
                                          sfu11+
                                          avail.forage, 
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
#p5.full.summary
full.data.p5 <- match.data(p5.out1) # pulls matched data out of matchit object. 


```

## Balance plot
```{r, echo = FALSE}
love.plot(bal.tab(p5.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p5.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p5.out1, "distance", which = "both")
# this returns a ggplot object
b+ theme_bw() # so just need to adjust the aesthetics.


```

# p6: Reserve Winter Pastures:
What additional covariates should we consider here?
```{r P6,}

p6.full.summary<- summary(p6.out1 <- matchit(p6 ~
                                          CBRM + 
                                          ez + 
                                          p4 +
                                          p5 + 
                                          ltmeanppt, 
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
# p6.full.summary
full.data.p6 <- match.data(p6.out1) # pulls matched data out of matchit object. 

# balanace.plot

love.plot(bal.tab(p6.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p6.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p6.out1, "distance", which = "both")
b+ theme_bw() 


```

## p7: Reserve Spring Pastures
```{r p7,}

p7.full.summary<- summary(p7.out1 <- matchit(p7 ~
                                          CBRM + 
                                          ez + 
                                          p4 +
                                          p5 + #+
                                          p6 +
                                          p8 +
                                          ltmeanppt,  
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
# p7.full.summary
full.data.p7 <- match.data(p7.out1) # pulls matched data out of matchit object. 

# balanace.plot

love.plot(bal.tab(p7.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p7.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p7.out1, "distance", which = "both")
b+ theme_bw() 


```

## p8: Reserve Dzud Pastures
```{r p8,}

p8.full.summary<- summary(p8.out1 <- matchit(p8 ~
                                          CBRM + 
                                          ez + 
                                          p4 +
                                          p5 + #+
                                          p6 +
                                          p7 +
                                          ltmeanppt, 
                                        data = raw.data, 
                                        method = "full", distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
# p8.full.summary
full.data.p8 <- match.data(p8.out1) # pulls matched data out of matchit object. 
## obtain matched data for the treatment group
p8.data.trt <- match.data(p8.out1, group = "treat")
p8.data.ctrl <- match.data(p8.out1, group = "control")

# balanace.plot

love.plot(bal.tab(p8.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p8.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p8.out1, "distance", which = "both")
b+ theme_bw() 


```

# Grazing out of Season

## p9: Grazing winter pastures in summer and fall
```{r P9,}

p9.full.summary<- summary(p9.out1 <- matchit(p9 ~
                                          avail.forage+
                                          ltmeansfu+ 
                                          CBRM + 
                                          ez + 
                                          Trsp+
                                          pl +
                                          p2s +
                                          p3s +
                                          p4 +
                                          p5 + 
                                          p10,
                                        data = raw.data, 
                                        method = "full", 
                                        distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
#p9.full.summary
full.data.p9 <- match.data(p9.out1) # pulls matched data out of matchit object. 
## obtain matched data for the treatment group

# balanace.plot

love.plot(bal.tab(p9.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p9.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p9.out1, "distance", which = "both")

b+ theme_bw() 
ggsave(a, filename = "./plots/p9_balance.png") #, width=2, height = 7)
ggsave(b, filename = "./plots/p9_PSprepot.png", width=5, height = 4)
#ggsave(c, filename = "./plots/p9_PSpost.png", width=5, height = 4)

```
## p10: Grazing dzud pastures in non-emergency
```{r P10, eval = FALSE, echo = FALSE}

p10.full.summary<- summary(p10.out1 <- matchit(p10 ~
                                          avail.forage+
                                          ltmeansfu+ 
                                          CBRM + 
                                          ez + 
                                          Trsp+
                                          pl +
                                          p2s +
                                          p3s +
                                          p4 +
                                          p5 + 
                                          p10,
                                        data = raw.data, 
                                        method = "full", 
                                        distance = "logit",
                                        discard = "both"
                                        ), standardize = TRUE  
                                        )
# get summary and generate dataset
p10.full.summary
full.data.p10 <- match.data(p10.out1) # pulls matched data out of matchit object. 
## obtain matched data for the treatment group
p10.data.trt <- match.data(p10.out1, group = "treat")
p10.data.ctrl <- match.data(p10.out1, group = "control")

# balanace.plot

love.plot(bal.tab(p10.out1), 
          stat =  "mean.diffs",   #c("mean.diffs", "variance.ratios", "ks.statistics"), 
          # cant' get var ratios for binary vars... can't get this to work unless select one stat msr at a time.
          threshold = .2,  #c(.2, 2), 
          no.missing = TRUE,
          var.order = NULL)

bal.tab(p10.out1, # the matchit object
        un = TRUE,  # print stats for unadjusted and adjusted sample?
        m.threshold = 0.2, #.1, # threshold for mean diffs. they suggest .1 which is more conservative than our 0.25 that we were using before
        int = FALSE, #include interactions?
        disp.means = TRUE,
        disp.v.ratio = TRUE,
        disp.ks =TRUE
        )
# 
b<- bal.plot(p10.out1, "distance", which = "both")

b+ theme_bw() 


```


In a matched sampling design, the sample average treatment effect for the treated can be estimated by computing the difference between the observed dependent variable for the treated group and their expected or predicted values of the dependent variable under no treatment.
SO compare the values of eco.int for P4=1 (in matched data or original raw??) vs. ev or pv of eco.int for p4=0

# IV. Results
### Figures and tables for comparing distributions of post-matched data:
```{r}
# set plotting params:
height = 3
width =3
pal1 = "Dark2" # palette for density plots
line1 = "grey35"  # color for Trt ab line
line2 = "grey55"  # color for Ctrl abline
```

### Results for 2 Ecological Factors:
### CBRM
#### Ecol Factor 1
```{r}
cbrm_0<-(full.data.m$eco1.rs*full.data.m$weights)[which(full.data.m$CBRM==0)]
cbrm_0pre<-(full.data.m$eco1.rs)[which(full.data.m$CBRM==0)]
cbrm_1<-(full.data.m$eco1.rs*full.data.m$weights)[which(full.data.m$CBRM==1)]
cbrm_1pre<-(full.data.m$eco1.rs)[which(full.data.m$CBRM==1)]
plot(ecdf(cbrm_0))
lines(ecdf(cbrm_1), col = 'blue')

ks.test(cbrm_0, cbrm_1)
t.test(cbrm_0, cbrm_1)
ks.test(cbrm_0pre, cbrm_1pre)
t.test(cbrm_0pre, cbrm_1pre)

# Density plots
ggplot(full.data.m, aes(x=(eco1.rs), colour=CBRM)) + 
  geom_density()+ 
    scale_color_brewer(type = 'div', palette = pal1)+
  theme(legend.position="none") +
  geom_vline(aes(xintercept = 0.63), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.69), color = line2, linetype = 3)+
  labs(title= "CBRM Treatment Effect\npre-matching data", x= "Ecological Index for Factor 1")
ggsave("./plots/cb1pre.png", height = height, width = width)
ggplot(full.data.m, aes(x=(eco1.rs *weights), colour=CBRM)) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  theme(legend.position="none") +
  geom_vline(aes(xintercept = 0.66), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.43), color = line2, linetype = 3)+
  labs(title="CBRM Treatment Effect\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/cb1post.png", height = height, width = width)

ggplot(full.data.m) + 
  geom_density(aes(x=(eco1.rs), colour=CBRM), linetype = 3)+ 
  geom_density(aes(x=(eco1.rs *weights), colour=CBRM))+
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.63), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.69), color = line2, linetype = 3)+
  labs(title= "CBRM Treatment Effect\npre-matching data", x= "Ecological Index for Factor 1")



# Means pre & post  --- # CAN'T
cbrm_mu<- full.data.m%>% group_by(CBRM)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Medians
cbrm_med<-full.data.m%>% group_by(CBRM)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#cb1<- gather(cbrm_med, "Trt", "Level", 1)


xc1<- bind_cols(cbrm_mu, cbrm_med)%>% rename(Level = CBRM) %>% mutate(Trt = as.factor(c("CBRM", "CBRM")))

```
#### Ecol Factor 2
```{r}
cbrm_0<-(full.data.m$eco2.rs*full.data.m$weights)[which(full.data.m$CBRM==0)]
cbrm_1<-(full.data.m$eco2.rs*full.data.m$weights)[which(full.data.m$CBRM==1)]
plot(ecdf(cbrm_0))
lines(ecdf(cbrm_1), col = 'blue')

ks.test(cbrm_0, cbrm_1)
t.test(cbrm_0, cbrm_1)
# Density plots
ggplot(full.data.m, aes(x=(eco2.rs), colour=CBRM)) + 
  geom_density()+ 
    scale_color_brewer(type = 'div', palette = "Dark2")+
  theme(legend.position="none") +
  geom_vline(aes(xintercept = 0.47), color = 'grey35', linetype = 2)+
  geom_vline(aes(xintercept = 0.44), color = 'grey45', linetype = 3)+
  labs(title= "CBRM Treatment Effect\npre-matching data", x= "Ecological Index for Factor 2")
ggsave("./plots/cb2pre.png", height = height, width = width)
ggplot(full.data.m, aes(x=(eco2.rs *weights), colour=CBRM)) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = "Dark2")+
  theme(legend.position="none") +
  geom_vline(aes(xintercept = 0.38), color = 'grey35', linetype = 2)+
  geom_vline(aes(xintercept = 0.23), color = 'grey45', linetype = 3)+
  labs(title="CBRM Treatment Effect\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/cb2post.png", height = height, width = width)

# Means pre & post   
cbrm2_mu<- full.data.m%>% group_by(CBRM)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Medians
cbrm2_med<-full.data.m%>% group_by(CBRM)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))
xc2<- bind_cols(cbrm2_mu, cbrm2_med)%>% rename(Level = CBRM) %>% mutate(Trt = as.factor(c("CBRM", "CBRM")))

#cb2<- gather(cbrm2_med, "Trt", "Level", 1)

```

## Trespassing:
#### Ecol Factor 1:
```{r}

tr_0<- (full.data.tr$eco1.rs*full.data.tr$weights)[which(full.data.tr$Trsp==0)]
plot(ecdf(tr_0))

tr_1<- (full.data.tr$eco1.rs*full.data.tr$weights)[which(full.data.tr$Trsp==1)]
lines(ecdf(tr_1), col = 'blue')
abline(h = 0.5, lty = 2, col='black' )

ks.test(tr_0, tr_1)
t.test(tr_0, tr_1)
# 

# Density plots

ggplot(full.data.tr, aes(x=(eco1.rs), colour=as.factor(Trsp))) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.68), color = line2, linetype = 3)+
  labs(title="Trespassing 'Effect'\npre-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/tr1pre.png", height = height, width = width)

ggplot(full.data.tr, aes(x=(eco1.rs *weights), colour=as.factor(Trsp))) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.28), color = line2, linetype = 3)+
  labs(title="Trespassing 'Effect'\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/tr1post.png", height = height, width = width)

# Means pre & post
trsp_mu<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))

trsp_med<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#tr1<- gather(trsp_med, "Trt", "Level", 1)

xtr1<- bind_cols(trsp_mu, trsp_med)%>% rename(Level = Trsp) %>% mutate(Trt = as.factor(c("Trsp", "Trsp")))

```

#### Ecol Factor 2:
```{r}

tr_0<- (full.data.tr$eco2.rs*full.data.tr$weights)[which(full.data.tr$Trsp==0)]
plot(ecdf(tr_0))

tr_1<- (full.data.tr$eco2.rs*full.data.tr$weights)[which(full.data.tr$Trsp==1)]
lines(ecdf(tr_1), col = 'blue')
abline(h = 0.5, lty = 2, col='black' )

ks.test(tr_0, tr_1)
t.test(tr_0, tr_1)
# 

# Density plots
ggplot(full.data.tr, aes(x=(eco2.rs), colour=as.factor(Trsp))) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.68), color = line2, linetype = 3)+
  labs(title="Trespassing 'Effect'\npre-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/tr2pre.png", height = height, width = width)

ggplot(full.data.tr, aes(x=(eco2.rs *weights), colour=as.factor(Trsp))) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.28), color = line2, linetype = 3)+
  labs(title="Trespassing 'Effect'\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/tr2post.png", height = height, width = width)
# Means pre & post
trsp2_mu<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))

trsp2_med<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))

#tr2<- gather(trsp2_med, "Trt", "Level", 1)

xtr2<- bind_cols(trsp2_mu, trsp2_med)%>% rename(Level = Trsp) %>% mutate(Trt = as.factor(c("Trsp", "Trsp")))

```
** This!!** 

## P4: Fall Otor
#### EF1:
```{r}

p4_0<- (full.data.p4$eco1.rs*full.data.p4$weights)[which(full.data.p4$p4==0)]


p4_1<- (full.data.p4$eco1.rs*full.data.p4$weights)[which(full.data.p4$p4==1)]
plot(ecdf(p4_0))
lines(ecdf(p4_1), col = 'blue')

ks.test(p4_0, p4_1)
t.test(p4_0, p4_1)
# 

# Density plots
ggplot(full.data.p4, aes(x=(eco1.rs*weights), colour=p4)) + geom_density()

ggplot(full.data.p4, aes(x=(eco1.rs), colour=as.factor(p4))) + 
  geom_density()+ 
  xlim(0, 2)+
  scale_color_brewer(type = 'div', palette = pal1)+
  theme(legend.position="none") +
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.69), color = line2, linetype = 3)+
  labs(title="Effect of Fall Otor\npre-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p41pre.png", height = height, width = width)

ggplot(full.data.p4, aes(x=(eco1.rs *weights), colour=as.factor(p4))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.23), color = line2, linetype = 3)+
  labs(title="Effect of Fall Otor\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p41post.png", height = height, width = width)

# Means pre & post
p4_mu<- full.data.p4%>% group_by(p4)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Medians
p4_med<- full.data.p4%>% group_by(p4)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p41<- gather(p4_med, "Trt", "Level", 1)

xp41<- bind_cols(p4_mu, p4_med)%>% rename(Level = p4) %>% mutate(Trt = as.factor(c("FallOtor", "FallOtor")))

```
#### EF2:
```{r}

p4_0<- (full.data.p4$eco2.rs*full.data.p4$weights)[which(full.data.p4$p4==0)]
plot(ecdf(p4_0))

p4_1<- (full.data.p4$eco2.rs*full.data.p4$weights)[which(full.data.p4$p4==1)]
lines(ecdf(p4_1), col = 'blue')

ks.test(p4_0, p4_1)
t.test(p4_0, p4_1)
# 

# Density plots
#ggplot(full.data.p4, aes(x=(eco2.rs*weights), colour=p4)) + geom_density()

ggplot(full.data.p4, aes(x=(eco2.rs), colour=as.factor(p4))) + 
  geom_density()+ 
  xlim(0, 3)+
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.64), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.69), color = line2, linetype = 3)+
  labs(title="Effect of Fall Otor\npre-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p42pre.png", height = height, width = width)

ggplot(full.data.p4, aes(x=(eco2.rs *weights), colour=as.factor(p4))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.38), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.16), color = line2, linetype = 3)+
  labs(title="Effect of Fall Otor\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p42post.png", height = height, width = width)

# Means pre & post
p42_mu<- full.data.p4%>% group_by(p4)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Medians
p42_med<- full.data.p4%>% group_by(p4)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))

#p42<- gather(p42_med, "Trt", "Level", 1)

xp42<- bind_cols(p42_mu, p42_med)%>% rename(Level = p4) %>% mutate(Trt = as.factor(c("FallOtor", "FallOtor")))
```
## P5: Winter Otor
#### EF1
```{r}

p5_0<- (full.data.p5$eco1.rs*full.data.p5$weights)[which(full.data.p5$p5==0)]
plot(ecdf(p5_0))

p5_1<- (full.data.p5$eco1.rs*full.data.p5$weights)[which(full.data.p5$p5==1)]
lines(ecdf(p5_1), col = 'blue')

ks.test(p5_0, p5_1)
t.test(p5_0, p5_1)
# 

# Density plots
ggplot(full.data.p5, aes(x=(eco1.rs *weights), colour=as.factor(p5))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.66), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.35), color = line2, linetype = 3)+
  labs(title="Effect of Winter Otor\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p51post.png", height = height, width = width)

# Means pre & post
p5_mu<- full.data.p5%>% group_by(p5)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Median pre & post
p5_med<- full.data.p5%>% group_by(p5)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p51<- gather(p5_med, "Trt", "Level", 1)

xp51<- bind_cols(p5_mu, p5_med)%>% rename(Level = p5) %>% mutate(Trt = as.factor(c("WinterOtor", "WinterOtor")))

```

#### EF2
```{r}

p5_0<- (full.data.p5$eco2.rs*full.data.p5$weights)[which(full.data.p5$p5==0)]
plot(ecdf(p5_0))

p5_1<- (full.data.p5$eco2.rs*full.data.p5$weights)[which(full.data.p5$p5==1)]
lines(ecdf(p5_1), col = 'blue')

ks.test(p5_0, p5_1)
t.test(p5_0, p5_1)
# 

# Density plots
ggplot(full.data.p5, aes(x=(eco2.rs *weights), colour=as.factor(p5))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.38), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.24), color = line2, linetype = 3)+
  labs(title="Effect of Winter Otor\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p52post.png", height = height, width = width)

# Means pre & post
p52_mu<- full.data.p5%>% group_by(p5)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Median pre & post
p52_med<- full.data.p5%>% group_by(p5)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))

#p52<- gather(p52_med, "Trt", "Level", 1)
xp52<- bind_cols(p52_mu, p52_med)%>% rename(Level = p5) %>% mutate(Trt = as.factor(c("WinterOtor", "WinterOtor")))
```

## P6: Reserve Winter Pastures
#### EF1
```{r}

p6_0<- (full.data.p6$eco1.rs*full.data.p6$weights)[which(full.data.p6$p6==0)]
plot(ecdf(p6_0))

p6_1<- (full.data.p6$eco1.rs*full.data.p6$weights)[which(full.data.p6$p6==1)]
lines(ecdf(p6_1), col = 'blue')

ks.test(p6_0, p6_1)
t.test(p6_0, p6_1)

# Density plots
ggplot(full.data.p6, aes(x=(eco1.rs *weights), colour=as.factor(p6))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.66), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.19), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Winter Pastures\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p61post.png", height = height, width = width)


# Means pre & post
p6_mu<- full.data.p6%>% group_by(p6)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Meedians pre & post
p6_med<- full.data.p6%>% group_by(p6)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p61<- gather(p6_med, "Trt", "Level", 1)

xp61<- bind_cols(p6_mu, p6_med)%>% rename(Level = p6) %>% mutate(Trt = as.factor(c("ResWinterPasture", "ResWinterPasture")))

```

#### EFA2
```{r}

p6_0<- (full.data.p6$eco2.rs*full.data.p6$weights)[which(full.data.p6$p6==0)]
plot(ecdf(p6_0))

p6_1<- (full.data.p6$eco2.rs*full.data.p6$weights)[which(full.data.p6$p6==1)]
lines(ecdf(p6_1), col = 'blue')

ks.test(p6_0, p6_1)
# Density plots
ggplot(full.data.p6, aes(x=(eco2.rs *weights), colour=as.factor(p6))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.40), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.13), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Winter Pastures\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p62post.png", height = height, width = width)

# Means pre & post
p62_mu<- full.data.p6%>% group_by(p6)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Meedians pre & post
p62_med<- full.data.p6%>% group_by(p6)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))
#x62<- bind_cols(p6_mu, p6_med)
#p62<- gather(p62_med, "Trt", "Level", 1)

xp62<- bind_cols(p62_mu, p62_med)%>% rename(Level = p6) %>% mutate(Trt = as.factor(c("ResWinterPasture", "ResWinterPasture")))

```


## p7: Reserve Spring Pastures
#### EF1
```{r}

p7_0<- (full.data.p7$eco1.rs*full.data.p7$weights)[which(full.data.p7$p7==0)]
plot(ecdf(p7_0))

p7_1<- (full.data.p7$eco1.rs*full.data.p7$weights)[which(full.data.p7$p7==1)]
lines(ecdf(p7_1), col = 'blue')

ks.test(p7_0, p7_1)
# 

# Density plots
ggplot(full.data.p7, aes(x=(eco1.rs *weights), colour=as.factor(p7))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.52), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.28), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Spring Pastures\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p71post.png", height = height, width = width)

# Means pre & post
p7_mu<- full.data.p7%>% group_by(p7)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Meedians pre & post
p7_med<- full.data.p7%>% group_by(p7)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p71<- gather(p7_med, "Trt", "Level", 1)
xp71<- bind_cols(p7_mu, p7_med)%>% rename(Level = p7) %>% mutate(Trt = as.factor(c("ResSPringPasture", "ResSpringPasture")))

```
#### EF2
```{r}

p7_0<- (full.data.p7$eco2.rs*full.data.p7$weights)[which(full.data.p7$p7==0)]
plot(ecdf(p7_0))

p7_1<- (full.data.p7$eco2.rs*full.data.p7$weights)[which(full.data.p7$p7==1)]
lines(ecdf(p7_1), col = 'blue')

ks.test(p7_0, p7_1)
# 

# Density plots
ggplot(full.data.p7, aes(x=(eco2.rs *weights), colour=as.factor(p7))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.34), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.18), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Spring Pastures\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p72post.png", height = height, width = width)


# Means pre & post
p72_mu<- full.data.p7%>% group_by(p7)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Meedians pre & post
p72_med<- full.data.p7%>% group_by(p7)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))
 
#p72<- gather(p72_med, "Trt", "Level", 1)

xp72<- bind_cols(p72_mu, p72_med)%>% rename(Level = p7) %>% mutate(Trt = as.factor(c("ResSPringPasture", "ResSpringPasture")))


```

## p8: Reserve Dzud Pastures
#### EF1
```{r}

p8_0<- (full.data.p8$eco1.rs*full.data.p8$weights)[which(full.data.p8$p8==0)]
plot(ecdf(p8_0))

p8_1<- (full.data.p8$eco1.rs*full.data.p8$weights)[which(full.data.p8$p8==1)]
lines(ecdf(p8_1), col = 'blue')

ks.test(p8_0, p8_1)

# Density plots
ggplot(full.data.p8, aes(x=(eco1.rs *weights), colour=as.factor(p8))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.67), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.28), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Dzud Pastures\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p81post.png", height = height, width = width)

# Means pre & post
p8_mu<- full.data.p8%>% group_by(p8)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))
# Meedians pre & post
p8_med<- full.data.p8%>% group_by(p8)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p81<- gather(p8_med, "Trt", "Level", 1)

xp81<- bind_cols(p8_mu, p8_med)%>% rename(Level = p8) %>% mutate(Trt = as.factor(c("ResDzudPasture", "ResDzudPasture")))


```

#### EF2
```{r}

p8_0<- (full.data.p8$eco2.rs*full.data.p8$weights)[which(full.data.p8$p8==0)]
plot(ecdf(p8_0))

p8_1<- (full.data.p8$eco2.rs*full.data.p8$weights)[which(full.data.p8$p8==1)]
lines(ecdf(p8_1), col = 'blue')

ks.test(p8_0, p8_1)

# Density plots
ggplot(full.data.p8, aes(x=(eco2.rs *weights), colour=as.factor(p8))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.44), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.18), color = line2, linetype = 3)+
  labs(title="Effect of Reserving Dzud Pastures\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p82post.png", height = height, width = width)

# Means pre & post
p82_mu<- full.data.p8%>% group_by(p8)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))
# Meedians pre & post
p82_med<- full.data.p8%>% group_by(p8)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))

#p82<- gather(p82_med, "Trt", "Level", 1)

xp82<- bind_cols(p82_mu, p82_med)%>% rename(Level = p8) %>% mutate(Trt = as.factor(c("ResDzudPasture", "ResDzudPasture")))

```

## P9: Grazed Winter-Sum/Fall
#### EF1
```{r}

p9_0<- (full.data.p9$eco1.rs*full.data.p9$weights)[which(full.data.p9$p9==0)]
plot(ecdf(p9_0))

p9_1<- (full.data.p9$eco1.rs*full.data.p9$weights)[which(full.data.p9$p9==1)]
lines(ecdf(p9_1), col = 'blue')

ks.test(p9_0, p9_1)
t.test(p9_0, p9_1)
# 

# Density plots
ggplot(full.data.p9, aes(x=(eco1.rs *weights), colour=as.factor(p9))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.67), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.49), color = line2, linetype = 3)+
  labs(title="Effect of Grazing Out of Season\npost-matched data", x= "Ecological Index for Factor 1")
ggsave("./plots/p91post.png", height = height, width = width)

# Means pre & post
p9_mu<- full.data.p9%>% group_by(p9)%>% summarise(pre= mean(eco1.rs), post= mean(eco1.rs*weights))

p9_med<- full.data.p9%>% group_by(p9)%>% summarise(pre= median(eco1.rs), post= median(eco1.rs*weights))

#p91<- gather(p9_med, "Trt", "Level", 1)

xp91<- bind_cols(p9_mu, p9_med)%>% rename(Level = p9) %>% mutate(Trt = as.factor(c("GrzOutSeason", "GrzOutSeason")))

```

#### EF2
```{r}

p9_0<- (full.data.p9$eco2.rs*full.data.p9$weights)[which(full.data.p9$p9==0)]
plot(ecdf(p9_0))

p9_1<- (full.data.p9$eco2.rs*full.data.p9$weights)[which(full.data.p9$p9==1)]
lines(ecdf(p9_1), col = 'blue')

ks.test(p9_0, p9_1)
# 

# Density plots

ggplot(full.data.p9, aes(x=(eco2.rs *weights), colour=as.factor(p9))) + 
  geom_density()+ 
  xlim(0, 3)+
  theme(legend.position="none") +
  scale_color_brewer(type = 'div', palette = pal1)+
  geom_vline(aes(xintercept = 0.39), color = line1, linetype = 2)+
  geom_vline(aes(xintercept = 0.33), color = line2, linetype = 3)+
  labs(title="Effect of Grazing Out of Season\npost-matched data", x= "Ecological Index for Factor 2")
ggsave("./plots/p92post.png", height = height, width = width)

# Means pre & post
p92_mu<- full.data.p9%>% group_by(p9)%>% summarise(pre= mean(eco2.rs), post= mean(eco2.rs*weights))

p92_med<- full.data.p9%>% group_by(p9)%>% summarise(pre= median(eco2.rs), post= median(eco2.rs*weights))

#p92<- gather(p92_med, "Trt", "Level", 1)

xp92<- bind_cols(p92_mu, p92_med)%>% rename(Level = p9) %>% mutate(Trt = as.factor(c("GrzOutSeason", "GrzOutSeason")))

```




## Summary of impact of Trt on Ecological Factors after matching:
```{r}
tr1$Level<- as.character(tr1$Level)
tr2$Level<- as.character(tr2$Level)

# SINGLE FACTOR VERSION
# medians<- bind_rows(cb, tr, p4, p5, p6, p7, p8, p9)%>%
#   gather(MatchStatus, Index, 1:2) 
# trt.lv<- medians[,1:2]
# medians %<>%
#   unite(Trt_Level, 1:2, sep = "_")%>%
#   bind_cols(trt.lv)%>%
#   mutate_at(5, funs(factor(.)))%>%
#   mutate(MatchStatus= factor(MatchStatus, levels = c("pre", "post")))
# 
# # rename the Levels so the LEgend labels make sense.
# levels( medians$Level)[levels( medians$Level)=="0"] <- "Control"
# levels( medians$Level)[levels( medians$Level)=="1"] <- "Treated"
# 
# meds<- ggplot(medians, aes(x= MatchStatus, y = Index, group= Trt_Level ))+
#   geom_point(aes(color = Trt, shape = Level), size = 2)+
#   geom_line(aes(linetype = Level, color = Trt))+
#   scale_color_brewer(type= "div", palette = "BrBG" )+
#   labs(y= "Median Ecological Index", x = "Matching Status", title = "Single Ecological Index")+
#   theme_bw()
# meds

#************************ TWO FACTOR VERSION:*******************

# First Factor:
tr1$Level<- as.character(tr1$Level)

F1medians<- bind_rows(cb1, tr1, p41, p51, p61, p71, p81, p91)%>%
  gather(MatchStatus, Index, 1:2) 
trt.lv<- F1medians[,1:2]
F1medians %<>%
  unite(Trt_Level, 1:2, sep = "_")%>%
  bind_cols(trt.lv)%>%
  mutate_at(5, funs(factor(.)))%>%
  mutate(MatchStatus= factor(MatchStatus, levels = c("pre", "post")))%>%
  mutate(Trt = factor(Trt))

# rename the Levels so the LEgend labels make sense.
levels(F1medians$Level)[levels(F1medians$Level)=="0"] <- "Control"
levels(F1medians$Level)[levels(F1medians$Level)=="1"] <- "Treated"
# rename the Treatments so labels make sense.
levels(F1medians$Trt) <- list(CBRM = "CBRM", 
                          FallOtor = "p4",   
                          WinterOtor = "p5",   
                          ResWntrPastures = "p6",
                          ResSprPastures = "p7",
                          ResDzudPastures = "p8",
                          GrazeOutSeasn = "p9",   
                          Trespassing = "Trsp")

F1meds<- ggplot(F1medians, aes(x= MatchStatus, y = Index, group= Trt_Level ))+
  geom_point(aes(color = Trt, shape = Level), size = 2)+
  geom_line(aes(linetype = Level, color = Trt), size = 1)+
  scale_color_brewer(type= "div", palette = "Spectral" )+
  labs(y= "Median Ecological Index", x = "Matching Status", title = "First Ecol Factor Index")+
  theme_light()
F1meds
ggsave(F1meds,  filename = "./plots/F1medians.png", width = 5, height = 6)
# Second Factor:
tr2$Level<- as.character(tr2$Level)
F2medians<- bind_rows(cb2, tr2, p42, p52, p62, p72, p82, p92)%>%
  gather(MatchStatus, Index, 1:2) 
trt.lv<- F2medians[,1:2]
F2medians %<>%
  unite(Trt_Level, 1:2, sep = "_")%>%
  bind_cols(trt.lv)%>%
  mutate_at(5, funs(factor(.)))%>%
  mutate(MatchStatus= factor(MatchStatus, levels = c("pre", "post")))%>%
  mutate(Trt = factor(Trt))

# rename the Treatments so labels make sense.
levels(F2medians$Trt) <- list(CBRM = "CBRM", 
                          FallOtor = "p4",   
                          WinterOtor = "p5",   
                          ResWntrPastures = "p6",
                          ResSprPastures = "p7",
                          ResDzudPastures = "p8",
                          GrazeOutSeasn = "p9",   
                          Trespassing = "Trsp")

F2meds<- ggplot(F2medians, aes(x= MatchStatus, y = Index, group= Trt_Level ))+
  geom_point(aes(color = Trt, shape = Level), size = 2)+
  geom_line(aes(linetype = Level, color = Trt))+
  scale_color_brewer(type= "div", palette = "Spectral" )+
  labs(y= "Median Ecological Index", x = "Matching Status", title = "Second Ecol Factor Index")+
  theme_light()
F2meds

```

## Summary Table
Create a table of means and medians

Factor 1
```{r}
xtr1$Trsp1<- as.factor(xtr1$Trsp1)
xtr1$Level<- as.factor(xtr1$Level)
EF1_Summary<- bind_rows(xc1, xtr1, xp41, xp51, xp61, xp71, xp81, xp91) %>%
  dplyr::select(Level:Trt) %>% dplyr::select(-CBRM1) %>%
  rename(Mean_Pre = pre,
         Mean_post = post,
         Median_Pre = pre1,
         Median_Post = post1)  
 
#write.csv(EF1_Summary, file= "./plots/EF1_Summary.csv")   
#kable(EF1_Summary, digits = 2, caption = "Ecological Factor 1")
```
Factor 2
```{r}
xtr2$Trsp1<- as.factor(xtr2$Trsp1)
xtr2$Level<- as.factor(xtr2$Level)
EF2_Summary<- bind_rows(xc2, xtr2, xp42, xp52, xp62, xp72, xp82, xp92) %>%
  dplyr::select(Level:Trt) %>% dplyr::select(-CBRM1) %>%
  rename(Mean_Pre = pre,
         Mean_post = post,
         Median_Pre = pre1,
         Median_Post = post1)  
 
write.csv(EF2_Summary, file= "./EF2_Summary.csv")   
#kable(EF2_Summary, digits = 2, caption = "Ecological Factor 2")




```









## RESULT FOR SINGLE ECOLOGICAL FACTOR 
While mean values for ecological condition were not different for the Trt and control across all comparisons, all except for Grazing Winter Pasture Out of Season resulted in significantly different distributions between the Treatment and Control groups, with significantly higher median values for Ecological Condition for the Treatment groups. 


### Figures and tables for comparing distributions of post-matched data:

## CBRM
```{r}
cbrm_0<-(full.data.m$eco.int*full.data.m$weights)[which(full.data.m$CBRM==0)]
cbrm_1<-(full.data.m$eco.int*full.data.m$weights)[which(full.data.m$CBRM==1)]
plot(ecdf(cbrm_0))
lines(ecdf(cbrm_1), col = 'blue')
abline(h=0.5, col = 'grey30', lty = 2)

ks.test(cbrm_0, cbrm_1)
t.test(cbrm_0, cbrm_1)
# Density plots
ggplot(full.data.m, aes(x=(eco.int*weights), colour=CBRM)) + geom_density()

# Means pre & post
cbrm_mu<- full.data.m%>% group_by(CBRM)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Medians
cbrm_med<-full.data.m%>% group_by(CBRM)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))
x<- bind_cols(cbrm_mu, cbrm_med)%>% rename(Level = CBRM) %>% mutate(Trt = as.factor(c("CBRM", "CBRM")))

cb<- gather(cbrm_med, "Trt", "Level", 1)

```
Distributions signif diff, Medians and distrib of CBRM = 1 shifted to higher.



## Tresspassing:
```{r}

tr_0<- (full.data.tr$eco.int*full.data.tr$weights)[which(full.data.tr$Trsp==0)]
plot(ecdf(tr_0))

tr_1<- (full.data.tr$eco.int*full.data.tr$weights)[which(full.data.tr$Trsp==1)]
lines(ecdf(tr_1), col = 'blue')
abline(h = 0.5, lty = 2, col='black' )

ks.test(tr_0, tr_1)
t.test(tr_0, tr_1)
# 

# Density plots
ggplot(full.data.tr, aes(x=(eco.int*weights), colour=as.factor(Trsp))) + 
  geom_density()+
  geom_vline(xintercept = median(eco.int*weights), color= as.factor(Trsp))

# Means pre & post
trsp_mu<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))

trsp_med<- full.data.tr%>% group_by(Trsp)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))

tr<- gather(trsp_med, "Trt", "Level", 1)

xtr<- bind_cols(trsp_mu, trsp_med)%>% rename(Level = Trsp) %>% mutate(Trt = as.factor(c("Trsp", "Trsp")))
```



#### P4
```{r}

p4_0<- (full.data.p4$eco.int*full.data.p4$weights)[which(full.data.p4$p4==0)]
plot(ecdf(p4_0))

p4_1<- (full.data.p4$eco.int*full.data.p4$weights)[which(full.data.p4$p4==1)]
lines(ecdf(p4_1), col = 'blue')

ks.test(p4_0, p4_1)
t.test(p4_0, p4_1)
# 

# Density plots
ggplot(full.data.p4, aes(x=(eco.int*weights), colour=p4)) + geom_density()
# Means pre & post
p4_mu<- full.data.p4%>% group_by(p4)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Medians
p4_med<- full.data.p4%>% group_by(p4)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))
xp4<- bind_cols(p4_mu, p4_med)%>% rename(Level = p4) %>% mutate(Trt = as.factor(c("FallOtor", "FallOtor")))

p4<- gather(p4_med, "Trt", "Level", 1)
```




## P5: Winter Otor
```{r}

p5_0<- (full.data.p5$eco.int*full.data.p5$weights)[which(full.data.p5$p5==0)]
plot(ecdf(p5_0))

p5_1<- (full.data.p5$eco.int*full.data.p5$weights)[which(full.data.p5$p5==1)]
lines(ecdf(p5_1), col = 'blue')

ks.test(p5_0, p5_1)
# 

# Density plots
ggplot(full.data.p5, aes(x=(eco.int*weights), colour=p5)) + geom_density()

# Means pre & post
p5_mu<- full.data.p5%>% group_by(p5)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Median pre & post
p5_med<- full.data.p5%>% group_by(p5)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))

p5<- gather(p5_med, "Trt", "Level", 1)

xp5<- bind_cols(p5_mu, p5_med)%>% rename(Level = p5) %>% mutate(Trt = as.factor(c("WinterOtor", "WinterOtor")))
```

## P6: Reserve Winter Pastures
```{r}

p6_0<- (full.data.p6$eco.int*full.data.p6$weights)[which(full.data.p6$p6==0)]
plot(ecdf(p6_0))

p6_1<- (full.data.p6$eco.int*full.data.p6$weights)[which(full.data.p6$p6==1)]
lines(ecdf(p6_1), col = 'blue')

ks.test(p6_0, p6_1)
# Density plots
ggplot(full.data.p6, aes(x=(eco.int*weights), colour=p6)) + geom_density()

# Means pre & post
p6_mu<- full.data.p6%>% group_by(p6)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Meedians pre & post
p6_med<- full.data.p6%>% group_by(p6)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))
xp6<- bind_cols(p6_mu, p6_med)%>% rename(Level = p6) %>% mutate(Trt = as.factor(c("ResWinterPasture", "ResWinterPasture")))
p6<- gather(p6_med, "Trt", "Level", 1)
```

## p7: Reserve Springr Pastures
```{r}

p7_0<- (full.data.p7$eco.int*full.data.p7$weights)[which(full.data.p7$p7==0)]
plot(ecdf(p7_0))

p7_1<- (full.data.p7$eco.int*full.data.p7$weights)[which(full.data.p7$p7==1)]
lines(ecdf(p7_1), col = 'blue')

ks.test(p7_0, p7_1)
# 

# Density plots


#ggplot(full.data.p7, aes(x=(eco.int*weights), colour=p7)) + geom_density()

# Means pre & post
p7_mu<- full.data.p7%>% group_by(p7)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Meedians pre & post
p7_med<- full.data.p7%>% group_by(p7)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))
 
p7<- gather(p7_med, "Trt", "Level", 1)

xp7<- bind_cols(p7_mu, p7_med)%>% rename(Level = p7) %>% mutate(Trt = as.factor(c("ResSPringPasture", "ResSpringPasture")))
```


## p8: Reserve Dzud Pastures
```{r}

p8_0<- (full.data.p8$eco.int*full.data.p8$weights)[which(full.data.p8$p8==0)]
plot(ecdf(p8_0))

p8_1<- (full.data.p8$eco.int*full.data.p8$weights)[which(full.data.p8$p8==1)]
lines(ecdf(p8_1), col = 'blue')

ks.test(p8_0, p8_1)

# Density plots
ggplot(full.data.p8, aes(x=(eco.int*weights), colour=p8)) + geom_density()

# Means pre & post
p8_mu<- full.data.p8%>% group_by(p8)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))
# Meedians pre & post
p8_med<- full.data.p8%>% group_by(p8)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))

p8<- gather(p8_med, "Trt", "Level", 1)

xp8<- bind_cols(p8_mu, p8_med)%>% rename(Level = p8) %>% mutate(Trt = as.factor(c("ResDzudPasture", "ResDzudPasture")))
```


## P9: Grazed Winter-Sum/Fall
```{r}

p9_0<- (full.data.p9$eco.int*full.data.p9$weights)[which(full.data.p9$p9==0)]
plot(ecdf(p9_0))

p9_1<- (full.data.p9$eco.int*full.data.p9$weights)[which(full.data.p9$p9==1)]
lines(ecdf(p9_1), col = 'blue')

ks.test(p9_0, p9_1)
# 

# Density plots
ggplot(full.data.p9, aes(x=(eco.int*weights), colour=p9)) + geom_density()

# Means pre & post
p9_mu<- full.data.p9%>% group_by(p9)%>% summarise(pre= mean(eco.int), post= mean(eco.int*weights))

p9_med<- full.data.p9%>% group_by(p9)%>% summarise(pre= median(eco.int), post= median(eco.int*weights))

p9<- gather(p9_med, "Trt", "Level", 1)

xp9<- bind_cols(p9_mu, p9_med)%>% rename(Level = p9) %>% mutate(Trt = as.factor(c("GrzOutSeason", "GrzOutSeason")))
```

## Summary of impact of Trt on Ecological Index after matching:
```{r}
tr$Level<- as.character(tr$Level)
medians<- bind_rows(cb, tr, p4, p5, p6, p7, p8, p9)%>%
  gather(MatchStatus, Index, 1:2) 
trt.lv<- medians[,1:2]
medians %<>%
  unite(Trt_Level, 1:2, sep = "_")%>%
  bind_cols(trt.lv)%>%
  mutate_at(5, funs(factor(.)))%>%
  mutate(MatchStatus= factor(MatchStatus, levels = c("pre", "post")))

# rename the Levels so the LEgend labels make sense.
levels(medians$Level)[levels(medians$Level)=="0"] <- "Control"
levels(medians$Level)[levels(medians$Level)=="1"] <- "Treated"


meds<- ggplot(medians, aes(x= MatchStatus, y = Index, group= Trt_Level ))+
  geom_point(aes(color = Trt, shape = Level), size = 2)+
  geom_line(aes(linetype = Level, color = Trt))+
  scale_color_brewer(type= "div", palette = "BrBG" )+
  labs(y= "Median Ecological Index", x = "Matching Status")+
  theme_bw()
meds



```




### some useful links and references: 

Add Stuart & King cites here.

[cobalt vignette](https://cran.r-project.org/web/packages/cobalt/vignettes/cobalt_basic_use.html) 
[Stanford tutorial](https://stanford.edu/~ejdemyr/r-tutorials-archive/tutorial8.html) on propensity score matching.

[ggjoy](https://cran.r-project.org/web/packages/ggjoy/vignettes/introduction.html) vignette.
[xtable](https://cran.r-project.org/web/packages/xtable/vignettes/xtableGallery.pdf)

[zelig commands](https://r.iq.harvard.edu/docs/zelig/3.4-8/Zelig_Commands.html)

# Explanatory Models: 
```{r Models}
#cbrm_mod <- lm(eco.int ~ CBRM , data= full.data.m, weights = full.data.m$weights)
cbrm_mod <- lm(eco1.rs ~ CBRM , data= full.data.m, weights = full.data.m$weights)
summary(cbrm_mod)
```


```{r}
cbrm_modw <- lm((eco1.rs*weights) ~ CBRM , data= full.data.m, weights = full.data.m$weights)
summary(cbrm_modw)
```

```{r}
zelig(eco1.rs ~ CBRM + ez + p4 +p5, data = full.data.m, weights = "weights", model = "ls")

```













