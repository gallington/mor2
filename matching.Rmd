---
title: "Matching"
output: html_notebook
---
```{r, message=FALSE}
library(MatchIt)
library(optmatch)
library(foreign)
library(dplyr)
library(tidyr)
library(ggplot2)
library(magrittr)
```

Initial matching trials w the MOR2 HH Survey data.... 

Steps:
1. bring in the data....
```{r , echo=FALSE, message=FALSE}
# STEP 1: subsetting the mor2 data:
# for use in matching....

# this is the data on just the 130 HH That have paired ecological data,
# along with their associated Organizational info
mor2<- read.spss("./data/ALL_EcolHHOrgMerged_byUvuljaa_03_15_17_Simplified.sav" , 
                 to.data.frame=TRUE,
                 use.value.labels=FALSE) #

# 
# tidy format
tbl_df(mor2)

hhmatch <- mor2 %>%
  dplyr ::select(CBRM,
         SoumCode,
         ez = EcologicalZone_4Code,
         RefNum = SocialSurveyReferenceNumber
         ) 

# here using rpe.lv from the efa._cfa.Rmd doc.
# these are the extracted latent means from the cfa of ecological variables
lvs<- readRDS("rpe_lv.R")
tbl_df(lvs)
hhmatch %<>% left_join(lvs[,c(2,8:17,56)], by= "RefNum")

```




2.

```{r, message=FALSE}
# matching for full dataset

match.data<- hhmatch %>% 
  na.omit() %>%
  mutate(eco.int = scales::rescale(eco.s.lv, to=c(0, 1)))   # rescale from 0-1.
m.full.summary<- summary(m.out1 <- matchit(CBRM ~ 
                                          ez + 
                                          SoumCode+
                                          p1 +
                                          p2 +
                                          p3 +
                                          p4 +
                                          p5 +
                                          p6 +
                                          p7 +
                                          p8 +
                                          p9 +
                                          p10, 
                                        data = match.data, 
                                        method = "full",   #, distance = "logit")
                                        discard = "both"
                                        ), standardize = TRUE  #, addlvariables = cfug_data[,c("fracforestICI00", "elev")]
                                        )
```
# get summary and generate dataset
```{r}
m.full.summary
full.data.m <- match.data(m.out1)
```
### plot matching results for matching on full data 
```{r}
# generate pre and post matching Std. Mean. Diff. datasets
full.sum.all <- m.full.summary$sum.all
full.sum.mat <- m.full.summary$sum.matched
full.sum.all <- rename(full.sum.all, StMeanDiff = "Std. Mean Diff.")
full.sum.mat <- rename(full.sum.mat, StMeanDiff = "Std. Mean Diff.")


# write matching results files
write.csv(full.sum.all, "./data/matching/full_prematching_hh.csv")
write.csv(full.sum.mat, "./data/matching/full_postmatching_hh.csv")

# generate column for covariates
covariates <- row.names(m.full.summary$sum.all)

# generate dataset for plotting
#### ASK JOHAN ABOUT THIS ONE NOT SURE 
StMeanDif <- data.frame(cbind(covariates, full.sum.all$StMeanDiff, full.sum.mat$StMeanDiff))
StMeanDif <- data.frame(cbind(covariates, full.sum.all$StMeanDiff, full.sum.mat$StMeanDiff))
StMeanDif$V2 <- as.numeric(paste(StMeanDif$V2))
StMeanDif$V3 <- as.numeric(paste(StMeanDif$V3))


# Q HERE TOO WHAT??
# change row names for variables so that they appear in order
levels(StMeanDif$covariates)[levels(StMeanDif$covariates)=="distance"]                  <- "a. Propensity_score"
#levels(StMeanDif$covariates)[levels(StMeanDif$covariates)=="prop_fug.area.post"]        <- "Q. CF area post 2000"
#levels(StMeanDif$covariates)[levels(StMeanDif$covariates)=="area_h"]                    <- "P. VDC size"
# ...

scaleFUN <- function(x) sprintf("%.2f", x)

```
# here's the actual plotting code:
```{r}
# plot Standardized mean differences
stmdif.full <- ggplot(StMeanDif, aes(y = covariates )) +
  geom_point(aes(x = V3), colour = "sienna4", size = 10, alpha = 1) + geom_point(aes(x = V3), colour = "orange", size = 8, alpha = 1) + # with replacement
  geom_point(aes(x = V2), colour = "black", size = 12, alpha = 1, shape = 1) +
  scale_x_continuous(limits=c(-1.1, 2.5), breaks = c(-1, -0.5, -0.25, 0, 0.25, 0.5, 1, 1.5, 2, 2.5)) +
  geom_vline(xintercept = 0, lty="dotted") +
  geom_vline(xintercept = -0.25, lty="dotted") +
  geom_vline(xintercept = 0.25, lty="dotted") +
  theme_classic() +
  xlab("Std. mean difference") +
  ylab("Matching covariates") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"))
stmdif.full
```

# generate propensity scores for full dataset
```{r}
pscores <- glm(CBRM ~
              ez + 
              SoumCode+
              p1 +
              p2 +
              p3 +
              p4 +
              p5 +
              p6 +
              p7 +
              p8 +
              p9 +
              p10, 
            data = match.data, family = binomial)


match.data$ps <- predict(pscores, type = "response")

```
# Plot Propensity Scores before matching
```{r}
full.pscore.pre <- ggplot(data=match.data) + 
  geom_density(data = match.data[which(match.data$CBRM == "0"), ], fill = "yellow3", color = "yellow4", alpha = 0.2, aes(x = ps)) +        
  geom_density(data = match.data[which(match.data$CBRM == "1"), ], fill = "navyblue", color = "mediumpurple4", alpha = 0.2, aes(x = ps)) + 
  xlim(-0.2, 1.2) +
  ylim(0, 4) +
  theme_classic() +
  xlab("Propensity score") +
  ylab("Density") +
  ggtitle("Before Matching") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        plot.title = element_text(size=18, face = "bold", hjust = 0.5),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")
  )
full.pscore.pre
```
# Plot Propensity Scores after matching
```{r}
full.pscore.post <- ggplot(data=full.data.m) + 
  geom_density(data = full.data.m[which(full.data.m$CBRM == "0"), ], fill = "yellow3", color = "yellow4", alpha = 0.2, aes(x = distance, weight = weights/sum(weights))) +
  geom_density(data = full.data.m[which(full.data.m$CBRM == "1"), ], fill = "navyblue", color = "mediumpurple4", alpha = 0.2, aes(x = distance)) +
  xlim(-0.2, 1.2) +
  ylim(0, 4) +
  theme_classic() +
  xlab("Propensity score") +
  ylab("Density") +
  ggtitle("After Matching") +
  theme(axis.title.x = element_text(size=12, vjust=-0.2),
        axis.text.x = element_text(size=12),
        axis.title.y = element_text(size=12, vjust=1),
        axis.text.y = element_text(size=12),
        plot.title = element_text(size=18, face = "bold", hjust = 0.5),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")
  )
full.pscore.post
```

# plot matching figures
```{r}
stmdif.full + scale_x_continuous(labels=scaleFUN)            # This should be 9" x 7" when exporting .pdf
grid.arrange(full.pscore.pre, full.pscore.post, ncol=1)      #  This should be 7" x 7" when exporting .pdf
```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).
